%% 创建一个石墨烯TB模型并拟合参数
% 
%% 创建石墨烯TB模型(step by step)
% * 声明一个空的模型；初始化其轨道数

Graphene = HR(2);
%% 
% * 修改POSCAR格式
%
% _generated by phonopy_
% 
% _1.0_
% 
% _2.4604399204208875    0.0000000000000000    0.0000000000000000_
% 
% _-1.2302199602104438    2.1308034755698513    0.0000000000000000_
% 
% _0.0000000000000000    0.0000000000000000   10.0000000000000000_
% 
% _C_
% 
% _2_
% 
% _Direct_
% 
% _0.6666666666666666  0.3333333333333333  0.0000000000000000 |C p z_| 
% 
% _0.3333333333333334  0.6666666666666667  0.0000000000000000 |C p z_|
%% 
% * 导入POSCAR

Graphene = Graphene <'POSCAR_pz';
% Graphene = Graphene.input_orb_struct('POSCAR')
Graphene.orbL
%% 
% * 进行 nn_sk 搜索
% * 这里 search_range 取 【1 1 0】，Accuracy 取小数点3位，maxR值取 5 埃

search_range = [1 1 0];
Accuracy = 3;
r_max_search = 5;
Graphene = Graphene.nn(search_range,Accuracy ,r_max_search);
%% 
% * 可以简要获取一下这一步的信息，看下Rnn排名

[Rnn,~,~,~] = Graphene.nn_information();
%% 
% * 这里我们取最近邻hopping

Graphen_single = Graphene.H_TBSK_gen('level_cut',1)
%% 
% * 查看一下体系的未知量（symbolic）

Graphen_single.symvar_list
%% 利用MATLAB(2020)控件调整参数
%% 
% * 导入 KPOINTS信息 高对称点 高对称路径

 Graphen_single = Graphen_single<'KPOINTS';
%% 
% * 创建滑块


VppP_1 = 2.3;
Fermi = 0;
%% 
% * 给TB中的符号化变量赋值

Graphene_n = Graphen_single.Subsall();
%% 
% * 生成 hr.dat

Graphene_n.Gen_hr()
%% 
% * 生成能带

EIGENCAR = Graphene_n.EIGENCAR_gen()-Fermi;
%% 
% * 画出能带

bandplot(EIGENCAR,[-6,6],...
    'title',"Graphene-TB-VppP_1="+string(VppP_1),'Color','b');
%% TBSK单参数拟合
% 设定拟合范围：

EIGENCAR_DFT = EIGENVAL_read;
options_extra.NBAND_range_DFT = [4:5];
options_extra.NBAND_range = [1:2];
options_extra.klist_range = [30:50];
%options_extra.E_range = [-2:2];
%% 
% 默认大小和斜率等权

options_extra.weight_list = [1,1];
%% 
% 键值对：
%% 
% * 'EIGENCAR_DFT' 为你的DFT 能带变量名
% * FITobj 为你的拟合对象变量名
% * 'extra' 为你的设定的能量范围
% * 'algorithm' 为你选择的比较方法 默认为同时比较大小和斜率
[FITobj, SubsIndexL] = fitprepare(Graphen_single);

Loss_func_GrapheneTB = @(para) TBkit.loss_func(para, ...
    'FITobj','FITobj',...
    'DFTBAND','EIGENCAR_DFT',...
    'extra','options_extra',...
    'algorithm','pure_comparison', ...
    'SubsIndexL',SubsIndexL ...
) ;                   
options = optimset('PlotFcns',@optimplotfval,'Display','iter');
VppP_1 = fminbnd(Loss_func_GrapheneTB,1,3,options);
Graphene_single_n = Graphen_single.subs(VppP_1);
EIGENCAR = Graphene_single_n.EIGENCAR_gen();
%% 
% * 使用bandcompare画出能带

bandplot({EIGENCAR_DFT,EIGENCAR} ,[-10,10],'title',"Graphene-TBvsDFT-VppP_1="+string(VppP_1),'legends',{'DFT','Fit'});
%% 利用MATLAB(2020)控件调整参数 - DFT
%% 
% * 导入DFT数据

EIGENCAR_DFT = EIGENVAL_read; 
%% 
% * 引入次近邻

Graphene_nnn = Graphene.H_TBSK_gen('level_cut',2); 
Graphene_nnn.symvar_list
%% 
% * 创建滑块

VppP_1 = 2.74;
VppP_2 = 0.;
Fermi = 0;
%% 
% * 给TB中的符号化变量赋值

Graphene_nnn = Graphene_nnn<'KPOINTS';
Graphene_n = Graphene_nnn.Subsall();
%% 
% * 生成能带

EIGENCAR = Graphene_n.EIGENCAR_gen()-Fermi;
%% 
% * 使用bandcompare画出能带

bandplot({EIGENCAR_DFT,EIGENCAR} ,[-10,10],'title',"Graphene-TBvsDFT-VppP_1="+string(VppP_1));
%% 
% 
%% 利用NM办法多参数拟合DFT

clear;
EIGENCAR_DFT = EIGENVAL_read; 
% generated by phonopy
% 
% 1.0
% 
% 2.4604399204208875    0.0000000000000000    0.0000000000000000
% 
% -1.2302199602104438    2.1308034755698513    0.0000000000000000
% 
% 0.0000000000000000    0.0000000000000000   10.0000000000000000
% 
% C
% 
% 8
% 
% Direct
% 
% 0.6666666666666666  0.3333333333333333  0.0000000000000000 C s I
% 
% 0.6666666666666666  0.3333333333333333  0.0000000000000000 C p x
% 
% 0.6666666666666666  0.3333333333333333  0.0000000000000000 C p y
% 
% 0.3333333333333334  0.6666666666666667  0.0000000000000000 C s I
% 
% 0.3333333333333334  0.6666666666666667  0.0000000000000000 C p x
% 
% 0.3333333333333334  0.6666666666666667  0.0000000000000000 C p y
% 
% 0.6666666666666666  0.3333333333333333  0.0000000000000000 C p z 
% 
% 0.3333333333333334  0.6666666666666667  0.0000000000000000 C p z
% 创建模型 Script模式

Graphene = HR.from_POSCAR_SE('POSCAR',...
'Type','mat',...
'search_range' ,[2 2 0],...
'r_max',2,...8
'level_cut',2);
Graphene.autohermi
% 利用MATLAB(2020)控件调整参数 - DFT

E__6_0 = -7;
E__6_1 = 0;
VppP_1 = 2.7;
VppS_1 = -4;
VspS_1 = -4;
VssS_1 = 4;
Fermi  = 0;
%% 
% 

Graphene_n = Graphene.Subsall();
%% 
% * 生成能带
% * 画出能带

bandcompare(Graphene_n.EIGENCAR_gen()-Fermi,EIGENCAR_DFT, [-20,20],'title',"Graphene-TBvsDFT-VppP_1="+string(VppP_1));

%% NM
% 拟合参数设置
% 设定拟合范围：

options_extra.NBAND_range_DFT = [1:4];
options_extra.NBAND_range = [1:4];
options_extra.klist_range = ':';
%% 
% 默认大小和斜率等权

options_extra.weight_list = [1,1];
%% 
% 键值对：
%% 
% * ‘EIGENCAR_DFT’ 为你的DFT 能带变量名
% * FITobj 为你的拟合对象变量名
% * ‘extra’ 为你的设定的能量范围
% * 'algorithm' 为你选择的比较方法 默认为同时比较大小和斜率

%FITobj = subs(Graphene,Graphene.symvar_list(2),0);

Loss_func_TB = @(para) TBkit.loss_func(para, ...
    'FITobj','FITobj',...
    'DFTBAND','EIGENCAR_DFT',...
    'extra','options_extra',...
    'algorithm','pure_comparison' ...
)          
% 初值给定

FITobj = Graphene.subs([sym('E__6_1') sym('VppP_1')],[0,2.71353]);
FITobj.symvar_list
x0 = [-7,-4,-4,4];
% 进行拟合

options = optimset('PlotFcns',@optimplotfval,'Display','iter');
x = fminsearch(Loss_func_TB,x0,options);
% 拟合结果

[Graphene_n,EQL] = FITobj.subs(x);
EQL
EIGENCAR = Graphene_n.EIGENCAR_gen()-Fermi;
%% 
% * 画出能带

bandcompare(EIGENCAR,EIGENCAR_DFT ,[-20,20],'title',"Graphene-TBvsDFT-VppP_1="+string(VppP_1));
%% Bayes 拟合（还不完善 慎用）
% 我们尝试在什么都不知道的情况下拟合能带
% 
% 开启*delta rule*

Graphene = HR.from_POSCAR_SE('POSCAR',...
'Type','mat',...
'search_range' ,[2 2 0],...
'r_max',4,...
'level_cut',2,...
'deltarule',1);
%% 
% 偶然情况下 我们可以参考 DFT2wannier的结果 (轨道顺序一致) （就没成功过）
% 
% 

EIGENCAR_DFT = EIGENVAL_read; 
GrapheneWan = HR.from_wannier90()
%[VarInit,EQL] =GetInit(Graphene,GrapheneWan,[0,0,0])
%% 
% 通过比照
% 
% $$E_0^6 =7.41207$$
% 
% $$E_1^6 =5.35906$$
% 
% $${\textrm{VppP}}_1 =-1.89184$$
% 
% $${\textrm{VssS}}_1 =0.346063$$
% 
% $${\textrm{VspS}}_1 =4.19456$$
% 
% $${\textrm{VppS}}_1 \;\;=\;?$$
% 
% $$\delta =?$$
% 构建Bayes 寻参模型
% 拟合参数设置
% 设定拟合范围：

options_extra = TBkit.FitOptionHelper(EIGENCAR_DFT,'dirac',...
'Noccu',4,'NBAND_range_DFT',1:4,'highK',[1,20,40,60],'GapThreshold',0.3);    
%% 
% 默认大小和斜率等权
% 
% 键值对：
%% 
% * ‘EIGENCAR_DFT’ 为你的DFT 能带变量名
% * FITobj 为你的拟合对象变量名
% * ‘extra’ 为你的设定的能量范围
% * 'algorithm' 为你选择的比较方法 默认为同时比较大小和斜率

extra_parm = 0;
Loss_func_TB = @(para,extra_parm) TBkit.loss_func(para,extra_parm, ...
    'FITobj','Graphene',...
    'DFTBAND','EIGENCAR_DFT',...
    'extra','options_extra',...
    'algorithm','dirac' ...
)       
% Bayse 模型设置

Varlist = Graphene.symvar_list
VarGuess = [7.41207,5.353906,-1.8901,0.3456,4.19456,0,0];
Varlock  = VarGuess;
VarFix = sym([]);
VarWidth = [10,10,5,7,7,7,1];
fixCriterion = 1e-2;
BayesCycle = 5;
for i = 1 : BayesCycle
    extra_parm = 1-i/BayesCycle;
    Ratio = 0.7 - 0.4*(i /BayesCycle);
    Max_num = 40 + 20*(i /BayesCycle);
    Loss_func = @(parm) Loss_func_TB(parm,extra_parm);
    %
    VarBayes = TBkit.VarBayes(Varlist,VarGuess,VarWidth,VarFix);
    results = bayesopt(Loss_func,VarBayes,'Verbose',1,...
        'AcquisitionFunctionName','expected-improvement-plus',...
        'ExplorationRatio',Ratio,...
        'MaxObjectiveEvaluations',Max_num ...
        );
    %
    VarGuess_nex_time = table2array(results.XAtMinEstimatedObjective);
    Varlock = VarGuess;
    VarWidth = VarWidth/2^i;
    fixVarible = abs(VarGuess_nex_time - VarGuess) < fixCriterion;
    VarFix = Varlist(fixVarible);
    VarGuess = VarGuess_nex_time;
end
%%
[Graphene_n,EQL] = Graphene.subs(VarGuess);
EQL
EIGENCAR = Graphene_n.EIGENCAR_gen();
%% 
% * 画出能带

bandcompare(EIGENCAR ,EIGENCAR_DFT,[-20,20]);

%% 
% 
% 
% 
% 
% 
% 
%